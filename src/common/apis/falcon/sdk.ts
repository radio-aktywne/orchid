// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from "./client";
import {
  CreateBrowserLoginFlowRequestSchema,
  CreateBrowserLoginFlowResponseSchema,
  CreateBrowserLogoutFlowRequestSchema,
  CreateBrowserLogoutFlowResponseSchema,
  CreateBrowserRecoveryFlowRequestSchema,
  CreateBrowserRecoveryFlowResponseSchema,
  CreateBrowserRegistrationFlowRequestSchema,
  CreateBrowserRegistrationFlowResponseSchema,
  CreateBrowserSettingsFlowRequestSchema,
  CreateBrowserSettingsFlowResponseSchema,
  CreateBrowserVerificationFlowRequestSchema,
  CreateBrowserVerificationFlowResponseSchema,
  CreateNativeLoginFlowRequestSchema,
  CreateNativeLoginFlowResponseSchema,
  CreateNativeRecoveryFlowRequestSchema,
  CreateNativeRecoveryFlowResponseSchema,
  CreateNativeRegistrationFlowRequestSchema,
  CreateNativeRegistrationFlowResponseSchema,
  CreateNativeSettingsFlowRequestSchema,
  CreateNativeSettingsFlowResponseSchema,
  CreateNativeVerificationFlowRequestSchema,
  CreateNativeVerificationFlowResponseSchema,
  DisableMyOtherSessionsRequestSchema,
  DisableMyOtherSessionsResponseSchema,
  DisableMySessionRequestSchema,
  DisableMySessionResponseSchema,
  ExchangeSessionTokenRequestSchema,
  ExchangeSessionTokenResponseSchema,
  GetFlowErrorRequestSchema,
  GetFlowErrorResponseSchema,
  GetIdentitySchemaRequestSchema,
  GetIdentitySchemaResponseSchema,
  GetLoginFlowRequestSchema,
  GetLoginFlowResponseSchema,
  GetRecoveryFlowRequestSchema,
  GetRecoveryFlowResponseSchema,
  GetRegistrationFlowRequestSchema,
  GetRegistrationFlowResponseSchema,
  GetSettingsFlowRequestSchema,
  GetSettingsFlowResponseSchema,
  GetVerificationFlowRequestSchema,
  GetVerificationFlowResponseSchema,
  GetWebAuthnJavaScriptRequestSchema,
  GetWebAuthnJavaScriptResponseSchema,
  IsAliveRequestSchema,
  IsAliveResponseSchema,
  IsReadyRequestSchema,
  IsReadyResponseSchema,
  ListIdentitySchemasRequestSchema,
  ListIdentitySchemasResponseSchema,
  ListMySessionsRequestSchema,
  ListMySessionsResponseSchema,
  PerformNativeLogoutRequestSchema,
  PerformNativeLogoutResponseSchema,
  ToSessionRequestSchema,
  ToSessionResponseSchema,
  UpdateLoginFlowRequestSchema,
  UpdateLoginFlowResponseSchema,
  UpdateLogoutFlowRequestSchema,
  UpdateLogoutFlowResponseSchema,
  UpdateRecoveryFlowRequestSchema,
  UpdateRecoveryFlowResponseSchema,
  UpdateRegistrationFlowRequestSchema,
  UpdateRegistrationFlowResponseSchema,
  UpdateSettingsFlowRequestSchema,
  UpdateSettingsFlowResponseSchema,
  UpdateVerificationFlowRequestSchema,
  UpdateVerificationFlowResponseSchema,
} from "./schemas";
import type {
  CreateBrowserLoginFlowErrors,
  CreateBrowserLoginFlowRequest,
  CreateBrowserLoginFlowResponses,
  CreateBrowserLogoutFlowErrors,
  CreateBrowserLogoutFlowRequest,
  CreateBrowserLogoutFlowResponses,
  CreateBrowserRecoveryFlowErrors,
  CreateBrowserRecoveryFlowRequest,
  CreateBrowserRecoveryFlowResponses,
  CreateBrowserRegistrationFlowErrors,
  CreateBrowserRegistrationFlowRequest,
  CreateBrowserRegistrationFlowResponses,
  CreateBrowserSettingsFlowErrors,
  CreateBrowserSettingsFlowRequest,
  CreateBrowserSettingsFlowResponses,
  CreateBrowserVerificationFlowErrors,
  CreateBrowserVerificationFlowRequest,
  CreateBrowserVerificationFlowResponses,
  CreateNativeLoginFlowErrors,
  CreateNativeLoginFlowRequest,
  CreateNativeLoginFlowResponses,
  CreateNativeRecoveryFlowErrors,
  CreateNativeRecoveryFlowRequest,
  CreateNativeRecoveryFlowResponses,
  CreateNativeRegistrationFlowErrors,
  CreateNativeRegistrationFlowRequest,
  CreateNativeRegistrationFlowResponses,
  CreateNativeSettingsFlowErrors,
  CreateNativeSettingsFlowRequest,
  CreateNativeSettingsFlowResponses,
  CreateNativeVerificationFlowErrors,
  CreateNativeVerificationFlowRequest,
  CreateNativeVerificationFlowResponses,
  DisableMyOtherSessionsErrors,
  DisableMyOtherSessionsRequest,
  DisableMyOtherSessionsResponses,
  DisableMySessionErrors,
  DisableMySessionRequest,
  DisableMySessionResponses,
  ExchangeSessionTokenErrors,
  ExchangeSessionTokenRequest,
  ExchangeSessionTokenResponses,
  GetFlowErrorErrors,
  GetFlowErrorRequest,
  GetFlowErrorResponses,
  GetIdentitySchemaErrors,
  GetIdentitySchemaRequest,
  GetIdentitySchemaResponses,
  GetLoginFlowErrors,
  GetLoginFlowRequest,
  GetLoginFlowResponses,
  GetRecoveryFlowErrors,
  GetRecoveryFlowRequest,
  GetRecoveryFlowResponses,
  GetRegistrationFlowErrors,
  GetRegistrationFlowRequest,
  GetRegistrationFlowResponses,
  GetSettingsFlowErrors,
  GetSettingsFlowRequest,
  GetSettingsFlowResponses,
  GetVerificationFlowErrors,
  GetVerificationFlowRequest,
  GetVerificationFlowResponses,
  GetWebAuthnJavaScriptRequest,
  GetWebAuthnJavaScriptResponses,
  IsAliveErrors,
  IsAliveRequest,
  IsAliveResponses,
  IsReadyErrors,
  IsReadyRequest,
  IsReadyResponses,
  ListIdentitySchemasErrors,
  ListIdentitySchemasRequest,
  ListIdentitySchemasResponses,
  ListMySessionsErrors,
  ListMySessionsRequest,
  ListMySessionsResponses,
  PerformNativeLogoutErrors,
  PerformNativeLogoutRequest,
  PerformNativeLogoutResponses,
  ToSessionErrors,
  ToSessionRequest,
  ToSessionResponses,
  UpdateLoginFlowErrors,
  UpdateLoginFlowRequest,
  UpdateLoginFlowResponses,
  UpdateLogoutFlowErrors,
  UpdateLogoutFlowRequest,
  UpdateLogoutFlowResponses,
  UpdateRecoveryFlowErrors,
  UpdateRecoveryFlowRequest,
  UpdateRecoveryFlowResponses,
  UpdateRegistrationFlowErrors,
  UpdateRegistrationFlowRequest,
  UpdateRegistrationFlowResponses,
  UpdateSettingsFlowErrors,
  UpdateSettingsFlowRequest,
  UpdateSettingsFlowResponses,
  UpdateVerificationFlowErrors,
  UpdateVerificationFlowRequest,
  UpdateVerificationFlowResponses,
} from "./types";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

class HeyApiClient {
  protected client: Client;

  constructor(args: { client: Client }) {
    this.client = args.client;
  }
}

class HeyApiRegistry<T> {
  private readonly defaultKey = "default";

  private readonly instances: Map<string, T> = new Map();

  get(key?: string): T {
    const instance = this.instances.get(key ?? this.defaultKey);
    if (!instance) {
      throw new Error(
        `No SDK client found. Create one with "new Sdk()" to fix this error.`,
      );
    }
    return instance;
  }

  set(value: T, key?: string): void {
    this.instances.set(key ?? this.defaultKey, value);
  }
}

export class Sdk extends HeyApiClient {
  public static readonly __registry = new HeyApiRegistry<Sdk>();

  constructor(args: { client: Client; key?: string }) {
    super(args);
    Sdk.__registry.set(this, args.key);
  }

  /**
   * Get WebAuthn JavaScript
   *
   * This endpoint provides JavaScript which is needed in order to perform WebAuthn login and registration.
   *
   * If you are building a JavaScript Browser App (e.g. in ReactJS or AngularJS) you will need to load this file:
   *
   * ```html
   * <script src="https://public-kratos.example.org/.well-known/ory/webauthn.js" type="script" async />
   * ```
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public getWebAuthnJavaScript<ThrowOnError extends boolean = false>(
    options?: Options<GetWebAuthnJavaScriptRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      GetWebAuthnJavaScriptResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetWebAuthnJavaScriptRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetWebAuthnJavaScriptResponseSchema.parseAsync(data),
      url: "/.well-known/ory/webauthn.js",
      ...options,
    });
  }

  /**
   * Check HTTP Server Status
   *
   * This endpoint returns a HTTP 200 status code when Ory Kratos is accepting incoming
   * HTTP requests. This status does currently not include checks whether the database connection is working.
   *
   * If the service supports TLS Edge Termination, this endpoint does not require the
   * `X-Forwarded-Proto` header to be set.
   *
   * Be aware that if you are running multiple nodes of this service, the health status will never
   * refer to the cluster state, only to a single instance.
   */
  public isAlive<ThrowOnError extends boolean = false>(
    options?: Options<IsAliveRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      IsAliveResponses,
      IsAliveErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await IsAliveRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await IsAliveResponseSchema.parseAsync(data),
      url: "/health/alive",
      ...options,
    });
  }

  /**
   * Check HTTP Server and Database Status
   *
   * This endpoint returns a HTTP 200 status code when Ory Kratos is up running and the environment dependencies (e.g.
   * the database) are responsive as well.
   *
   * If the service supports TLS Edge Termination, this endpoint does not require the
   * `X-Forwarded-Proto` header to be set.
   *
   * Be aware that if you are running multiple nodes of Ory Kratos, the health status will never
   * refer to the cluster state, only to a single instance.
   */
  public isReady<ThrowOnError extends boolean = false>(
    options?: Options<IsReadyRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      IsReadyResponses,
      IsReadyErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await IsReadyRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await IsReadyResponseSchema.parseAsync(data),
      url: "/health/ready",
      ...options,
    });
  }

  /**
   * Get all Identity Schemas
   *
   * Returns a list of all identity schemas currently in use.
   */
  public listIdentitySchemas<ThrowOnError extends boolean = false>(
    options?: Options<ListIdentitySchemasRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      ListIdentitySchemasResponses,
      ListIdentitySchemasErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await ListIdentitySchemasRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await ListIdentitySchemasResponseSchema.parseAsync(data),
      url: "/schemas",
      ...options,
    });
  }

  /**
   * Get Identity JSON Schema
   *
   * Return a specific identity schema.
   */
  public getIdentitySchema<ThrowOnError extends boolean = false>(
    options: Options<GetIdentitySchemaRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetIdentitySchemaResponses,
      GetIdentitySchemaErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetIdentitySchemaRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetIdentitySchemaResponseSchema.parseAsync(data),
      url: "/schemas/{id}",
      ...options,
    });
  }

  /**
   * Get User-Flow Errors
   *
   * This endpoint returns the error associated with a user-facing self service errors.
   *
   * This endpoint supports stub values to help you implement the error UI:
   *
   * `?id=stub:500` - returns a stub 500 (Internal Server Error) error.
   *
   * More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
   */
  public getFlowError<ThrowOnError extends boolean = false>(
    options: Options<GetFlowErrorRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetFlowErrorResponses,
      GetFlowErrorErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetFlowErrorRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetFlowErrorResponseSchema.parseAsync(data),
      url: "/self-service/errors",
      ...options,
    });
  }

  /**
   * Submit a Login Flow
   *
   * Use this endpoint to complete a login flow. This endpoint
   * behaves differently for API and browser flows.
   *
   * API flows expect `application/json` to be sent in the body and responds with
   * HTTP 200 and a application/json body with the session token on success;
   * HTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;
   * HTTP 400 on form validation errors.
   *
   * Browser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with
   * a HTTP 303 redirect to the post/after login URL or the `return_to` value if it was set and if the login succeeded;
   * a HTTP 303 redirect to the login UI URL with the flow ID containing the validation errors otherwise.
   *
   * Browser flows with an accept header of `application/json` will not redirect but instead respond with
   * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
   * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
   * HTTP 400 on form validation errors.
   *
   * If this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
   * Most likely used in Social Sign In flows.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public updateLoginFlow<ThrowOnError extends boolean = false>(
    options: Options<UpdateLoginFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      UpdateLoginFlowResponses,
      UpdateLoginFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateLoginFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateLoginFlowResponseSchema.parseAsync(data),
      url: "/self-service/login",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create Login Flow for Native Apps
   *
   * This endpoint initiates a login flow for native apps that do not use a browser, such as mobile devices, smart TVs, and so on.
   *
   * If a valid provided session cookie or session token is provided, a 400 Bad Request error
   * will be returned unless the URL query parameter `?refresh=true` is set.
   *
   * To fetch an existing login flow call `/self-service/login/flows?flow=<flow_id>`.
   *
   * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
   * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
   * you vulnerable to a variety of CSRF attacks, including CSRF login attacks.
   *
   * In the case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   *
   * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public createNativeLoginFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateNativeLoginFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateNativeLoginFlowResponses,
      CreateNativeLoginFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateNativeLoginFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateNativeLoginFlowResponseSchema.parseAsync(data),
      url: "/self-service/login/api",
      ...options,
    });
  }

  /**
   * Create Login Flow for Browsers
   *
   * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate
   * cookies and anti-CSRF measures required for browser-based flows.
   *
   * If this endpoint is opened as a link in the browser, it will be redirected to
   * `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
   * exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter
   * `?refresh=true` was set.
   *
   * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   *
   * The optional query parameter login_challenge is set when using Kratos with
   * Hydra in an OAuth2 flow. See the oauth2_provider.url configuration
   * option.
   *
   * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public createBrowserLoginFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserLoginFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserLoginFlowResponses,
      CreateBrowserLoginFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserLoginFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserLoginFlowResponseSchema.parseAsync(data),
      url: "/self-service/login/browser",
      ...options,
    });
  }

  /**
   * Get Login Flow
   *
   * This endpoint returns a login flow's context with, for example, error details and other information.
   *
   * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
   * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
   *
   * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
   * and you need to forward the incoming HTTP Cookie header to this endpoint:
   *
   * ```js
   * pseudo-code example
   * router.get('/login', async function (req, res) {
   * const flow = await client.getLoginFlow(req.header('cookie'), req.query['flow'])
   *
   * res.render('login', flow)
   * })
   * ```
   *
   * This request may fail due to several reasons. The `error.id` can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `self_service_flow_expired`: The flow is expired and you should request a new one.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public getLoginFlow<ThrowOnError extends boolean = false>(
    options: Options<GetLoginFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetLoginFlowResponses,
      GetLoginFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetLoginFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetLoginFlowResponseSchema.parseAsync(data),
      url: "/self-service/login/flows",
      ...options,
    });
  }

  /**
   * Update Logout Flow
   *
   * This endpoint logs out an identity in a self-service manner.
   *
   * If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other)
   * to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.
   *
   * If the `Accept` HTTP header is set to `application/json`, a 204 No Content response
   * will be sent on successful logout instead.
   *
   * This endpoint is NOT INTENDED for API clients and only works
   * with browsers (Chrome, Firefox, ...). For API clients you can
   * call the `/self-service/logout/api` URL directly with the Ory Session Token.
   *
   * More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
   */
  public updateLogoutFlow<ThrowOnError extends boolean = false>(
    options?: Options<UpdateLogoutFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      UpdateLogoutFlowResponses,
      UpdateLogoutFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateLogoutFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateLogoutFlowResponseSchema.parseAsync(data),
      url: "/self-service/logout",
      ...options,
    });
  }

  /**
   * Perform Logout for Native Apps
   *
   * Use this endpoint to log out an identity using an Ory Session Token. If the Ory Session Token was successfully
   * revoked, the server returns a 204 No Content response. A 204 No Content response is also sent when
   * the Ory Session Token has been revoked already before.
   *
   * If the Ory Session Token is malformed or does not exist a 403 Forbidden response will be returned.
   *
   * This endpoint does not remove any HTTP
   * Cookies - use the Browser-Based Self-Service Logout Flow instead.
   */
  public performNativeLogout<ThrowOnError extends boolean = false>(
    options: Options<PerformNativeLogoutRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      PerformNativeLogoutResponses,
      PerformNativeLogoutErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PerformNativeLogoutRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PerformNativeLogoutResponseSchema.parseAsync(data),
      url: "/self-service/logout/api",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create a Logout URL for Browsers
   *
   * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.
   *
   * This endpoint is NOT INTENDED for API clients and only works
   * with browsers (Chrome, Firefox, ...). For API clients you can
   * call the `/self-service/logout/api` URL directly with the Ory Session Token.
   *
   * The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns
   * a 401 error.
   *
   * When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
   */
  public createBrowserLogoutFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserLogoutFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserLogoutFlowResponses,
      CreateBrowserLogoutFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserLogoutFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserLogoutFlowResponseSchema.parseAsync(data),
      url: "/self-service/logout/browser",
      ...options,
    });
  }

  /**
   * Update Recovery Flow
   *
   * Use this endpoint to update a recovery flow. This endpoint
   * behaves differently for API and browser flows and has several states:
   *
   * `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
   * and works with API- and Browser-initiated flows.
   * For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid.
   * and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired).
   * For Browser clients without HTTP Header `Accept` or with `Accept: text*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended.
   * `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It
   * works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
   * `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a recovery link")
   * does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
   * (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with
   * a new Recovery Flow ID which contains an error message that the recovery link was invalid.
   *
   * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
   */
  public updateRecoveryFlow<ThrowOnError extends boolean = false>(
    options: Options<UpdateRecoveryFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      UpdateRecoveryFlowResponses,
      UpdateRecoveryFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateRecoveryFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateRecoveryFlowResponseSchema.parseAsync(data),
      url: "/self-service/recovery",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create Recovery Flow for Native Apps
   *
   * This endpoint initiates a recovery flow for API clients such as mobile devices, smart TVs, and so on.
   *
   * If a valid provided session cookie or session token is provided, a 400 Bad Request error.
   *
   * On an existing recovery flow, use the `getRecoveryFlow` API endpoint.
   *
   * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
   * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
   * you vulnerable to a variety of CSRF attacks.
   *
   * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
   *
   * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
   */
  public createNativeRecoveryFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateNativeRecoveryFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateNativeRecoveryFlowResponses,
      CreateNativeRecoveryFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateNativeRecoveryFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateNativeRecoveryFlowResponseSchema.parseAsync(data),
      url: "/self-service/recovery/api",
      ...options,
    });
  }

  /**
   * Create Recovery Flow for Browsers
   *
   * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to
   * `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
   * exists, the browser is returned to the configured return URL.
   *
   * If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects
   * or a 400 bad request error if the user is already authenticated.
   *
   * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
   *
   * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
   */
  public createBrowserRecoveryFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserRecoveryFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserRecoveryFlowResponses,
      CreateBrowserRecoveryFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserRecoveryFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserRecoveryFlowResponseSchema.parseAsync(data),
      url: "/self-service/recovery/browser",
      ...options,
    });
  }

  /**
   * Get Recovery Flow
   *
   * This endpoint returns a recovery flow's context with, for example, error details and other information.
   *
   * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
   * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
   *
   * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
   * and you need to forward the incoming HTTP Cookie header to this endpoint:
   *
   * ```js
   * pseudo-code example
   * router.get('/recovery', async function (req, res) {
   * const flow = await client.getRecoveryFlow(req.header('Cookie'), req.query['flow'])
   *
   * res.render('recovery', flow)
   * })
   * ```
   *
   * More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
   */
  public getRecoveryFlow<ThrowOnError extends boolean = false>(
    options: Options<GetRecoveryFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetRecoveryFlowResponses,
      GetRecoveryFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetRecoveryFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetRecoveryFlowResponseSchema.parseAsync(data),
      url: "/self-service/recovery/flows",
      ...options,
    });
  }

  /**
   * Update Registration Flow
   *
   * Use this endpoint to complete a registration flow by sending an identity's traits and password. This endpoint
   * behaves differently for API and browser flows.
   *
   * API flows expect `application/json` to be sent in the body and respond with
   * HTTP 200 and a application/json body with the created identity success - if the session hook is configured the
   * `session` and `session_token` will also be included;
   * HTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;
   * HTTP 400 on form validation errors.
   *
   * Browser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with
   * a HTTP 303 redirect to the post/after registration URL or the `return_to` value if it was set and if the registration succeeded;
   * a HTTP 303 redirect to the registration UI URL with the flow ID containing the validation errors otherwise.
   *
   * Browser flows with an accept header of `application/json` will not redirect but instead respond with
   * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
   * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
   * HTTP 400 on form validation errors.
   *
   * If this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
   * Most likely used in Social Sign In flows.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public updateRegistrationFlow<ThrowOnError extends boolean = false>(
    options: Options<UpdateRegistrationFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      UpdateRegistrationFlowResponses,
      UpdateRegistrationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateRegistrationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateRegistrationFlowResponseSchema.parseAsync(data),
      url: "/self-service/registration",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create Registration Flow for Native Apps
   *
   * This endpoint initiates a registration flow for API clients such as mobile devices, smart TVs, and so on.
   *
   * If a valid provided session cookie or session token is provided, a 400 Bad Request error
   * will be returned unless the URL query parameter `?refresh=true` is set.
   *
   * To fetch an existing registration flow call `/self-service/registration/flows?flow=<flow_id>`.
   *
   * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
   * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
   * you vulnerable to a variety of CSRF attacks.
   *
   * In the case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   *
   * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public createNativeRegistrationFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateNativeRegistrationFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateNativeRegistrationFlowResponses,
      CreateNativeRegistrationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateNativeRegistrationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateNativeRegistrationFlowResponseSchema.parseAsync(data),
      url: "/self-service/registration/api",
      ...options,
    });
  }

  /**
   * Create Registration Flow for Browsers
   *
   * This endpoint initializes a browser-based user registration flow. This endpoint will set the appropriate
   * cookies and anti-CSRF measures required for browser-based flows.
   *
   * If this endpoint is opened as a link in the browser, it will be redirected to
   * `selfservice.flows.registration.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session
   * exists already, the browser will be redirected to `urls.default_redirect_url`.
   *
   * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   *
   * If this endpoint is called via an AJAX request, the response contains the registration flow without a redirect.
   *
   * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public createBrowserRegistrationFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserRegistrationFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserRegistrationFlowResponses,
      CreateBrowserRegistrationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserRegistrationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserRegistrationFlowResponseSchema.parseAsync(data),
      url: "/self-service/registration/browser",
      ...options,
    });
  }

  /**
   * Get Registration Flow
   *
   * This endpoint returns a registration flow's context with, for example, error details and other information.
   *
   * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
   * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
   *
   * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
   * and you need to forward the incoming HTTP Cookie header to this endpoint:
   *
   * ```js
   * pseudo-code example
   * router.get('/registration', async function (req, res) {
   * const flow = await client.getRegistrationFlow(req.header('cookie'), req.query['flow'])
   *
   * res.render('registration', flow)
   * })
   * ```
   *
   * This request may fail due to several reasons. The `error.id` can be one of:
   *
   * `session_already_available`: The user is already signed in.
   * `self_service_flow_expired`: The flow is expired and you should request a new one.
   *
   * More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
   */
  public getRegistrationFlow<ThrowOnError extends boolean = false>(
    options: Options<GetRegistrationFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetRegistrationFlowResponses,
      GetRegistrationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetRegistrationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetRegistrationFlowResponseSchema.parseAsync(data),
      url: "/self-service/registration/flows",
      ...options,
    });
  }

  /**
   * Complete Settings Flow
   *
   * Use this endpoint to complete a settings flow by sending an identity's updated password. This endpoint
   * behaves differently for API and browser flows.
   *
   * API-initiated flows expect `application/json` to be sent in the body and respond with
   * HTTP 200 and an application/json body with the session token on success;
   * HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set;
   * HTTP 400 on form validation errors.
   * HTTP 401 when the endpoint is called without a valid session token.
   * HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.
   * Implies that the user needs to re-authenticate.
   *
   * Browser flows without HTTP Header `Accept` or with `Accept: text*` respond with
   * a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded;
   * a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise.
   * a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.
   *
   * Browser flows with HTTP Header `Accept: application/json` respond with
   * HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;
   * HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;
   * HTTP 401 when the endpoint is called without a valid session cookie.
   * HTTP 403 when the page is accessed without a session cookie or the session's AAL is too low.
   * HTTP 400 on form validation errors.
   *
   * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
   * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
   * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
   * to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.
   *
   * If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect
   * the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`,
   * or initiate a refresh login flow otherwise.
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `session_inactive`: No Ory Session was found - sign in a user first.
   * `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other
   * identity logged in instead.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   * `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.
   * Most likely used in Social Sign In flows.
   *
   * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
   */
  public updateSettingsFlow<ThrowOnError extends boolean = false>(
    options: Options<UpdateSettingsFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      UpdateSettingsFlowResponses,
      UpdateSettingsFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateSettingsFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateSettingsFlowResponseSchema.parseAsync(data),
      url: "/self-service/settings",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create Settings Flow for Native Apps
   *
   * This endpoint initiates a settings flow for API clients such as mobile devices, smart TVs, and so on.
   * You must provide a valid Ory Kratos Session Token for this endpoint to respond with HTTP 200 OK.
   *
   * To fetch an existing settings flow call `/self-service/settings/flows?flow=<flow_id>`.
   *
   * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
   * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
   * you vulnerable to a variety of CSRF attacks.
   *
   * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
   * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
   * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
   * to sign in with the second factor or change the configuration.
   *
   * In the case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `session_inactive`: No Ory Session was found - sign in a user first.
   *
   * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
   *
   * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
   */
  public createNativeSettingsFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateNativeSettingsFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateNativeSettingsFlowResponses,
      CreateNativeSettingsFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateNativeSettingsFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateNativeSettingsFlowResponseSchema.parseAsync(data),
      url: "/self-service/settings/api",
      ...options,
    });
  }

  /**
   * Create Settings Flow for Browsers
   *
   * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to
   * `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid
   * Ory Kratos Session Cookie is included in the request, a login flow will be initialized.
   *
   * If this endpoint is opened as a link in the browser, it will be redirected to
   * `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session
   * was set, the browser will be redirected to the login endpoint.
   *
   * If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects
   * or a 401 forbidden error if no valid session was set.
   *
   * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
   * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
   * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
   * to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.
   *
   * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `session_inactive`: No Ory Session was found - sign in a user first.
   * `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!
   *
   * This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.
   *
   * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
   */
  public createBrowserSettingsFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserSettingsFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserSettingsFlowResponses,
      CreateBrowserSettingsFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserSettingsFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserSettingsFlowResponseSchema.parseAsync(data),
      url: "/self-service/settings/browser",
      ...options,
    });
  }

  /**
   * Get Settings Flow
   *
   * When accessing this endpoint through Ory Kratos' Public API you must ensure that either the Ory Kratos Session Cookie
   * or the Ory Kratos Session Token are set.
   *
   * Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator
   * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
   * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
   * to sign in with the second factor or change the configuration.
   *
   * You can access this endpoint without credentials when using Ory Kratos' Admin API.
   *
   * If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the
   * case of an error, the `error.id` of the JSON response body can be one of:
   *
   * `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.
   * `session_inactive`: No Ory Session was found - sign in a user first.
   * `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other
   * identity logged in instead.
   *
   * More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
   */
  public getSettingsFlow<ThrowOnError extends boolean = false>(
    options: Options<GetSettingsFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetSettingsFlowResponses,
      GetSettingsFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetSettingsFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetSettingsFlowResponseSchema.parseAsync(data),
      url: "/self-service/settings/flows",
      ...options,
    });
  }

  /**
   * Complete Verification Flow
   *
   * Use this endpoint to complete a verification flow. This endpoint
   * behaves differently for API and browser flows and has several states:
   *
   * `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent
   * and works with API- and Browser-initiated flows.
   * For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid
   * and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).
   * For Browser clients without HTTP Header `Accept` or with `Accept: text*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended.
   * `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It
   * works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.
   * `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow ("sending a verification link")
   * does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL
   * (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with
   * a new Verification Flow ID which contains an error message that the verification link was invalid.
   *
   * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
   */
  public updateVerificationFlow<ThrowOnError extends boolean = false>(
    options: Options<UpdateVerificationFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      UpdateVerificationFlowResponses,
      UpdateVerificationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await UpdateVerificationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await UpdateVerificationFlowResponseSchema.parseAsync(data),
      url: "/self-service/verification",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Create Verification Flow for Native Apps
   *
   * This endpoint initiates a verification flow for API clients such as mobile devices, smart TVs, and so on.
   *
   * To fetch an existing verification flow call `/self-service/verification/flows?flow=<flow_id>`.
   *
   * You MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server
   * Pages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make
   * you vulnerable to a variety of CSRF attacks.
   *
   * This endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).
   *
   * More information can be found at [Ory Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
   */
  public createNativeVerificationFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateNativeVerificationFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateNativeVerificationFlowResponses,
      CreateNativeVerificationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateNativeVerificationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateNativeVerificationFlowResponseSchema.parseAsync(data),
      url: "/self-service/verification/api",
      ...options,
    });
  }

  /**
   * Create Verification Flow for Browser Clients
   *
   * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to
   * `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.
   *
   * If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.
   *
   * This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).
   *
   * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
   */
  public createBrowserVerificationFlow<ThrowOnError extends boolean = false>(
    options?: Options<CreateBrowserVerificationFlowRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      CreateBrowserVerificationFlowResponses,
      CreateBrowserVerificationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await CreateBrowserVerificationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await CreateBrowserVerificationFlowResponseSchema.parseAsync(data),
      url: "/self-service/verification/browser",
      ...options,
    });
  }

  /**
   * Get Verification Flow
   *
   * This endpoint returns a verification flow's context with, for example, error details and other information.
   *
   * Browser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.
   * For AJAX requests you must ensure that cookies are included in the request or requests will fail.
   *
   * If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain
   * and you need to forward the incoming HTTP Cookie header to this endpoint:
   *
   * ```js
   * pseudo-code example
   * router.get('/recovery', async function (req, res) {
   * const flow = await client.getVerificationFlow(req.header('cookie'), req.query['flow'])
   *
   * res.render('verification', flow)
   * })
   * ```
   *
   * More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
   */
  public getVerificationFlow<ThrowOnError extends boolean = false>(
    options: Options<GetVerificationFlowRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      GetVerificationFlowResponses,
      GetVerificationFlowErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await GetVerificationFlowRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await GetVerificationFlowResponseSchema.parseAsync(data),
      url: "/self-service/verification/flows",
      ...options,
    });
  }

  /**
   * Disable my other sessions
   *
   * Calling this endpoint invalidates all except the current session that belong to the logged-in user.
   * Session data are not deleted.
   */
  public disableMyOtherSessions<ThrowOnError extends boolean = false>(
    options?: Options<DisableMyOtherSessionsRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).delete<
      DisableMyOtherSessionsResponses,
      DisableMyOtherSessionsErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await DisableMyOtherSessionsRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await DisableMyOtherSessionsResponseSchema.parseAsync(data),
      url: "/sessions",
      ...options,
    });
  }

  /**
   * Get My Active Sessions
   *
   * This endpoints returns all other active sessions that belong to the logged-in user.
   * The current session can be retrieved by calling the `/sessions/whoami` endpoint.
   */
  public listMySessions<ThrowOnError extends boolean = false>(
    options?: Options<ListMySessionsRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      ListMySessionsResponses,
      ListMySessionsErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await ListMySessionsRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await ListMySessionsResponseSchema.parseAsync(data),
      url: "/sessions",
      ...options,
    });
  }

  /**
   * Exchange Session Token
   */
  public exchangeSessionToken<ThrowOnError extends boolean = false>(
    options: Options<ExchangeSessionTokenRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      ExchangeSessionTokenResponses,
      ExchangeSessionTokenErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await ExchangeSessionTokenRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await ExchangeSessionTokenResponseSchema.parseAsync(data),
      url: "/sessions/token-exchange",
      ...options,
    });
  }

  /**
   * Check Who the Current HTTP Session Belongs To
   *
   * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated.
   * Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent.
   * When the request it successful it adds the user ID to the 'X-Kratos-Authenticated-Identity-Id' header
   * in the response.
   *
   * If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:
   *
   * ```js
   * pseudo-code example
   * router.get('/protected-endpoint', async function (req, res) {
   * const session = await client.toSession(undefined, req.header('cookie'))
   *
   * console.log(session)
   * })
   * ```
   *
   * When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:
   *
   * ```js
   * pseudo-code example
   * ...
   * const session = await client.toSession("the-session-token")
   *
   * console.log(session)
   * ```
   *
   * When using a token template, the token is included in the `tokenized` field of the session.
   *
   * ```js
   * pseudo-code example
   * ...
   * const session = await client.toSession("the-session-token", { tokenize_as: "example-jwt-template" })
   *
   * console.log(session.tokenized) // The JWT
   * ```
   *
   * Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator
   * Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn
   * credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user
   * to sign in with the second factor or change the configuration.
   *
   * This endpoint is useful for:
   *
   * AJAX calls. Remember to send credentials and set up CORS correctly!
   * Reverse proxies and API Gateways
   * Server-side calls - use the `X-Session-Token` header!
   *
   * This endpoint authenticates users by checking:
   *
   * if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie;
   * if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token;
   * if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.
   *
   * If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.
   *
   * As explained above, this request may fail due to several reasons. The `error.id` can be one of:
   *
   * `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token).
   * `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
   */
  public toSession<ThrowOnError extends boolean = false>(
    options?: Options<ToSessionRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      ToSessionResponses,
      ToSessionErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await ToSessionRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await ToSessionResponseSchema.parseAsync(data),
      url: "/sessions/whoami",
      ...options,
    });
  }

  /**
   * Disable one of my sessions
   *
   * Calling this endpoint invalidates the specified session. The current session cannot be revoked.
   * Session data are not deleted.
   */
  public disableMySession<ThrowOnError extends boolean = false>(
    options: Options<DisableMySessionRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      DisableMySessionResponses,
      DisableMySessionErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await DisableMySessionRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await DisableMySessionResponseSchema.parseAsync(data),
      url: "/sessions/{id}",
      ...options,
    });
  }
}
